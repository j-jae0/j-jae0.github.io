---
title:  "[프로그래머스 Python] Lv 1. 가장 가까운 같은 글자"
excerpt: "목표: 프로그래머스 Lv 1 끝내기"
layout: single

categories: "Algorithm_Python"

toc: true
toc_sticky: true
toc_label : "목차"
toc_icon: "bars"
---

***

# 문제 설명
문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.
예를 들어, s="banana"라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.
- b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
- n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
- a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.

따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.<br>
문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.

## 제한사항
- 1 ≤ s의 길이 ≤ 10,000
  - s은 영어 소문자로만 이루어져 있습니다.
- [문제 보러가기](https://school.programmers.co.kr/learn/courses/30/lessons/142086)

<br>

# 문제 풀이
## (1) 코드 작성
```python
def solution(s):
    dic = {}
    answer = []
    for alpha in s:
        if alpha not in dic.keys():
            answer.append(-1)
            dic[alpha] = 0
            for dk in dic.keys():
                dic[dk] += 1
        else:
            answer.append(dic[alpha])
            dic[alpha] = 0
            for dk in dic.keys():
                dic[dk] += 1
    return answer
```

## (2) 코드 리뷰
알파벳별로 위치를 저장하기 위해 딕셔너리에 담았다. 반복문을 통해 문자열의 문자를 하나씩 불러와 딕셔너리 키값에 존재하지 않는다면 출력해야 될 리스트에 -1값을 추가하였다. 그리고 딕셔너리에 key 값에 알파벳을, value 값엔 0으로 담고 딕셔너리에 있는 모든 키값들의 value 값에 1을 더했다(위치 이동을 고려함). 만약 딕셔너리에 key 값에 순회하는 알파벳이 존재한다면 딕셔너리에 저장해둔 위치(몇 칸 앞에 있는지 저장해둔 값)를 리스트에 담도록 했다. 그리고 기존의 알파벳보다 추후에 올 알파벳 입장에선 더 가까운 알파벳이 생겼으므로 위치를 0으로 초기화했다. 그리고 한 칸 더 이동해야 하기 때문에 딕셔너리에 존재하는 모든 알파벳의 value 값에 1을 더해주었다.

👩🏻‍💻개인 공부 기록용 블로그입니다
<br>오류나 틀린 부분이 있을 경우 댓글 혹은 메일로 따끔하게 지적해주시면 감사하겠습니다.
{: .notice}